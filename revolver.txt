
C++ high-performance service framework revolver: supports 1 million timed event timers at the same time

https://blog.fireheart.in/a?ID=00000-cad01cef-7452-4145-9d86-70d12c34b37b

github.com/yuanrongxi//

In high-performance server programs, the timer is an indispensable component, and the efficiency of the timer directly affects the performance of the service. In many open source projects, timer design has its own methods. For example, ACE and libEvent both use the smallest heap algorithm to achieve, and there are other open source projects that use a balanced binary tree as a timer management algorithm. Regardless of the minimum heap or the balanced binary tree, the timer scan is O(1), but the timer insertion and deletion are both O(logN) complexity. In the case of few timing events, this algorithm is sufficient. If there are more than millions of timing events, efficiency will become a bottleneck. Therefore, revolver does not use a general balanced binary tree and minimum heap in the implementation of timers, but uses a round-robin HASH algorithm for timer management.

What is the round-robin HASH algorithm? Cycle HASH triggers timing events through the rotation of 4 time wheels, just like the relationship between the second wheel, minute wheel, and hour wheel of a clock. As shown in the figure:

Each round has 256 scales, and 4 rounds are just a uint32_t integer number. One scale of the smallest round represents the event loop time of a reactor (5ms)
1. Timer scan

1) Get the current system time cur_ts, judge that the gap between prev_ts and the last scan time exceeds the minimum scale, and calculate the number of minimum scales that need to be rotated

scale = (cur_ts-prev_ts)/loop_delay;

2) Perform the first round of rotation, rotate the scales, and all the timing events in the rotating scales will be triggered. If the maximum scale of 256 is not exceeded after rotation, the rotation ends.

3) If it exceeds the maximum scale of 256, then rotate 1 scale from its parent wheel (second round). Map all the timing events of the scale on the parent wheel to the child wheel according to time. This is equivalent to repeating 2 steps. This is an iterative process. If the parent reaches 256, then continue to rotate the parent wheel of the parent wheel. Until it reaches the fourth round of rotation. This is the same as the principle that the minute hand moves one scale when the second moves one circle.

code show as below:

[cpp]  view plain  copy

    template<class HANDLER, class FUNCTOR, class LOCK>  
    uint32_t CTimerQueue_T<HANDLER, FUNCTOR, LOCK>::expire()  
    {  
        BASE_GUARD_RETURN(LOCK, cf_mon, mutex_, 0);  
        uint32_t ret = SELECT_DELAY;//default 20MS  
      
        CBaseTimeValue cur_timer = CBaseTimeValue::get_time_value();  
          
        if(cur_timer> prev_time_)  
        {  
            uint32_t scale = static_cast<uint32_t>((cur_timer.msec()-prev_time_.msec())/SELECT_DELAY);  
            if(scale> 0)  
            {  
                ret = revolver(scale);  
                prev_time_ = cur_timer;  
            }  
        }  
      
        return ret;  
    }  
      
    template<class HANDLER, class FUNCTOR, class LOCK>  
    uint32_t CTimerQueue_T<HANDLER, FUNCTOR, LOCK>::revolver(uint32_t scale)  
    {  
        //std::cout << "pos, first = "<< rings_[0].get_pos() << ", second =" << rings_[1].get_pos()  
        //<< ", third = "<< rings_[2].get_pos() << ", fourth =" << rings_[3].get_pos() <<std::endl;  
      
        uint32_t ret = SELECT_DELAY;  
      
        uint8_t index = 0;  
        uint32_t rewind_scale = scale;  
        while(rewind_scale> 0)  
        {  
            index = 0;  
            if(rings_[index].cycle(rewind_scale, this))//scan the first round  
            {  
                index ++;  
                uint32_t sc = 1;  
                while(rings_[index].cycle(sc, this))//Scan the next round, the scale will only advance 1 grid  
                {  
                    sc = 1;  
                    index ++;  
                    if(index >= RINGS_SIZE)  
                    {  
                        start_time_ = CBaseTimeValue::get_time_value();  
                        break;  
                    }  
                }  
            }  
        }  
      
        return ret;  
    }  

2. Insertion of timed events

1) First calculate the distance between the moment to be triggered and the current moment of the timer wheel

d = (cur_ts-start_ts + delay)/loop_delay;

2) Calculate the positions of the 4 wheels separately

first = (uint8_t)(timeout_stamp_/FIRST_ROUND);
second = (uint8_t)((timeout_stamp_% FIRST_ROUND)/SECOND_ROUND);
third = (uint8_t)((timeout_stamp_% SECOND_ROUND)/THIRD_ROUND_stamp)
( timeout) % );

3) Save to the corresponding wheel scale to get the result through calculation, and the insertion is complete. For example, if the calculated first = 0, second = 2, third = 30, fouth = 1, it will be saved to the second scale of the third round.

    template<class HANDLER, class FUNCTOR, class LOCK>  
    uint32_t CTimerQueue_T<HANDLER, FUNCTOR, LOCK>::schedule(HANDLER handler, const void *act, uint32_t delay, uint32_t interval)  
    {  
        BASE_GUARD_RETURN(LOCK, cf_mon, mutex_, 0);  
      
        BaseTimerNode_T<HANDLER>* timer_obj = node_pool_.pop_obj();  
        if(timer_obj != NULL)  
        {  
            uint32_t timer_id = get_free_node();  
            CBaseTimeValue cur_timer = CBaseTimeValue::get_time_value();  
            //Calculate distance  
            uint64_t distance = delay/SELECT_DELAY;//Use the current time as the coordinates directly, the difference is a scan interval of 20MS  
            if(cur_timer> start_time_)  
                distance = (cur_timer.msec()-start_time_.msec() + delay)/SELECT_DELAY;  
            distance = distance% (UNINT32_MAX);  
            timer_obj->set(handler, act, (uint32_t)(core_max(distance, 1)), interval, timer_id);  
            heap_[timer_id] = timer_obj;  
      
            used_num_ ++;  
            //Insert event  
            insert_node(timer_obj);  
            upcall_functor().registration(timer_obj->get_handler(), timer_id);  
            return timer_id;  
        }  
        return 0;  
    }  
      
    template<class HANDLER, class FUNCTOR, class LOCK>  
    void CTimerQueue_T<HANDLER, FUNCTOR, LOCK>::insert_node(BaseTimerNode_T<HANDLER>* node)  
    {  
        uint32_t timer_id = node->get_timer_id();  
      
        uint8_t poss[RINGS_SIZE] = {0};  
        //Get location  
        node->get_revolver_pos(poss[RINGS_SIZE-1], poss[RINGS_SIZE-2], poss[RINGS_SIZE-3], poss[RINGS_SIZE-4]);  
        uint8_t index = RINGS_SIZE-1;  
        //Insert  
        while(!rings_[index].add_element(poss[index], timer_id))  
        {  
            if(index == 0)  
                break;  
      
            index --;  
        }  
    }  

3. Deletion of timed events

Similar steps for deleting and inserting calculations

1) First calculate the distance between the time when the timing event needs to be deleted and the current time of the timer wheel

d = (cur_ts-start_ts + delay)/loop_delay;

2) Calculate the positions of the 4 wheels separately

first = (uint8_t)(timeout_stamp_/FIRST_ROUND); second = (uint8_t)((timeout_stamp_% FIRST_ROUND)/SECOND_ROUND);
third = (uint8_t)((timeout_stamp_% SECOND_ROUND)/THIRD_ROUND_stamp)
( timeout) % );

3) Find the corresponding wheel position according to the position coordinates and delete the timing event on the wheel

    template<class HANDLER, class FUNCTOR, class LOCK>  
    void CTimerQueue_T<HANDLER, FUNCTOR, LOCK>::cancel_timer(uint32_t timer_id, const void **act)  
    {  
        BASE_GUARD(LOCK, cf_mon, mutex_);  
        if(timer_id <heap_size_ && heap_[timer_id] != NULL)  
        {  
            //Find the corresponding timing event content  
            BaseTimerNode_T<HANDLER>* timer_obj = heap_[timer_id];  
            //Delete the timing event on the wheel  
            delete_node(timer_obj);  
      
            heap_[timer_id] = NULL;  
            if(used_num_> 0)  
                used_num_ --;  
      
            freeTimers_.push_back(timer_id);  
            *act = timer_obj->get_act();  
            upcall_functor().cancel_timer(timer_obj->get_handler(), timer_id);  
      
            node_pool_.push_obj(timer_obj);  
        }  
    }  
      
    template<class HANDLER, class FUNCTOR, class LOCK>  
    void CTimerQueue_T<HANDLER, FUNCTOR, LOCK>::delete_node(BaseTimerNode_T<HANDLER>* node)  
    {  
        uint32_t timer_id = node->get_timer_id();  
        uint8_t poss[RINGS_SIZE] = {0};  
        node->get_revolver_pos(poss[RINGS_SIZE-1], poss[RINGS_SIZE-2], poss[RINGS_SIZE-3], poss[RINGS_SIZE-4]);  
        //Delete the corresponding timing event  
        for(uint8_t index = 0; index <RINGS_SIZE; index ++)//Delete on each round  
        {  
            rings_[index].delete_element(poss[index], timer_id);  
        }  
    }  

4. Test

Remove the test_timer_queue comment in the main() function in the test project of revovler,
and then the test can be performed. The following is the code of test_timer_queue:

    void test_timer_queue()  
    {  
        srand(time(NULL));  
      
        CTimerFunctor functor;  
        TIMEQUEUE timer_queue(&functor);  
        CTest_Event_Handler handler;  
      
        handler.tq_ = &timer_queue;  
      
        CBaseTimeValue begin_timer = CBaseTimeValue::get_time_value();  
        for(int i = 0; i <1000000; i ++)  
        {  
            insert_timer(&handler, (rand()% 240) * 1000, timer_queue);  
        }  
        CBaseTimeValue stop_timer = CBaseTimeValue::get_time_value();  
        stop_timer = stop_timer-begin_timer;  
        std::cout << "insert 1000000 timer, delay = "<< stop_timer.msec() <<" MS" << std::endl;  
      
        g_ts = stop_timer.get_time_value().msec();  
    #if _DEBUG  
        //timer_queue.set_ring_id();  
    #endif  
        std::cout << "exprie ......" << std::endl;  
        while(1)  
        {  
            uint32_t ms = timer_queue.expire();  
            usleep((1000));  
        }  
    }  

This function can test how much time it takes to insert 1 million timed events. When 100 timed events are managed by the timer, both the CPU and memory can be monitored and viewed accordingly. The information of my release version under window 7 is as follows:

From the above figure, it takes 978MS to insert 1 million timed events. That is to say, when there are hundreds of thousands of timed events running, it only takes 0.97 microseconds to insert a timed event.

The following is a graph of CPU and memory usage during the processing of 1 million timed events.

5. Summary

The implementation of the timer has reached the efficiency originally envisaged in terms of efficiency and function, but the memory usage is slightly too high (120M). If implemented with C code, strict control and memory management of the memory should be much better. , The future optimization work should focus on this. If you need the complete code, please go to: github.com/yuanrongxi/...download  .

int main () 
{ 
  // Creating a min-heap. 
  priority_queue <int, vector<int>, greater<int> > minheap; 
  minheap.push(10); 
  minheap.push(1); 
  minheap.push(0); 
  minheap.push(8); 
  minheap.push(7); 
  minheap.push(2);
  // Removing the element at the root of the min-heap k-1 times.
  for(int i = 0; i < 2; i++){ 
      minheap.pop(); 
  } 
  // Displaying the element at the root of the min-heap.
  cout<<"The third smallest element in the given array is: "
  <<minheap.top() << endl; 
  return 0; 
} 

Insert in a priority_queue with the current time + number of seconds to wait before triggering the event.
